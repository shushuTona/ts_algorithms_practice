# [Heap](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/heap)

## memo

### Heap

- HeapからそのままInstanceは生成できない（= Heapを継承したClassからInstanceを生成する）
- 1つの親Nodeに対して、2つの子Nodeが紐づけられる（二分木として表現される木構造？）
- `heapContainer`は値を管理する配列（最初は空）
- `compare`は`Comparator Class`のインスタンス
- getLeftChildIndex
    - 引数の数値（`parentIndex`）を2倍して、1プラスした数値を戻り値とする関数
    - 対象Nodeの左側の子Nodeのindex番号を取得する
- getRightChildIndex
    - 引数の数値（`parentIndex`）を2倍して、2プラスした数値を戻り値とする関数
    - 対象Nodeの右側の子Nodeのindex番号を取得する
- getParentIndex
    - 引数の数値（`childIndex`）を基に、親Nodeのindex番号を取得する
    - 引数として `0` = `ルートノードのindex番号` を指定すると、式が `Math.floor((0-1)/2)` になるので、戻り値は `-1` になる
- hasParent
    - 引数の数値（`childIndex`）を基に、対象のindex番号のNodeに親Nodeが存在するか判定する
    - `getParentIndex`の処理結果を基にした真偽値取得
- hasLeftChild
    - 引数の数値（`parentIndex`）に対応するNodeの左側の子Nodeが存在するか判定する
    - `getLeftChildIndex`の処理結果を基にした真偽値取得
- hasRightChild
    - 引数の数値（`parentIndex`）に対応するNodeの右側の子Nodeが存在するか判定する
    - `getRightChildIndex`の処理結果を基にした真偽値取得
- leftChild
    - 引数の数値（`parentIndex`）に対応するNodeの左側の子Nodeを取得する
    - `getLeftChildIndex`を基に対象の子Nodeのindex番号を取得して、`heapContainer`から要素取得
- rightChild
    - 引数の数値（`parentIndex`）に対応するNodeの右側の子Nodeを取得する
    - `getRightChildIndex`を基に対象の子Nodeのindex番号を取得して、`heapContainer`から要素取得
- parent
    - 引数の数値（`childIndex`）に対応するNodeの親Nodeを取得する
    - `getParentIndex`を基に対象の子Nodeのindex番号を取得して、`heapContainer`から要素取得
- swap
    - 引数の2つのindex番号を基に、各index番号に対応する2つのNodeの位置を変更する
- peek
    - ルートノードの値を取得する
    - `heapContainer`に要素が存在しない場合は`null`が戻り値になる
- poll
    - `heapContainer`内の最後のNodeをルートノードに設定する
    - `heapContainer`に対して`pop`を実行して、削除＆追加Nodeの取得をしている
    - `heapifyDown`は今のところ謎
- add
    - 引数で指定した値を`heapContainer`に`push`で追加する
    - `heapifyUp`は今のところ謎
- remove
    - XXX
    - XXX
    - XXX
- find
    - 引数の値と一致するNodeのindex番号を追加した配列を取得する
- isEmpty
    - `heapContainer`に要素が存在するかを判定する
- toString
    - `heapContainer`（Array）を`toString`で文字列化する
- heapifyUp
    - 対象Nodeとその親Nodeの値を比較して、pairIsInCorrectOrderの結果によって子Nodeと親Nodeの値を入れ替える
        - MaxHeapの場合：ルートNodeが最大値になるように値を入れ替えていく
        - MaxHeapの場合：ルートNodeが最小値になるように値を入れ替えていく
- heapifyDown
    - 対象Nodeとその子Nodeの値を比較して、pairIsInCorrectOrderの結果によって親Nodeと子Nodeの値を入れ替える
        - MaxHeapの場合：対象Indexとその子を比較して、子Nodeの方が大きい場合、親Nodeと子Nodeの位置を入れ替える
        - MaxHeapの場合：
- pairIsInCorrectOrder
    - 継承先のClassで上書きするメソッド
    - 上書きをしないで実行するとエラーが発生するようになっている
